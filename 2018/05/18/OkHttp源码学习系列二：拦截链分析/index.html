<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>OkHttp源码学习系列二：拦截链分析 | 业松 Studio</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文为本人原创，转载请注明作者和出处。   在上一章我们分析了Okhttp分发器对同步&#x2F;异步请求的处理，本章将和大家一起分析Okhttp的最核心模块–拦截链的代码。在这里你将会了解到Okhttp究竟如何处理请求的。  系列文章索引：OkHttp源码学习系列一：总流程和Dispatcher分析OkHttp源码学习系列二：拦截链分析OkHttp源码学习系列三：缓存总结 ###零、拦截链总流程上一章我">
<meta property="og:type" content="article">
<meta property="og:title" content="OkHttp源码学习系列二：拦截链分析">
<meta property="og:url" content="http://yoursite.com/2018/05/18/OkHttp%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E6%8B%A6%E6%88%AA%E9%93%BE%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="业松 Studio">
<meta property="og:description" content="本文为本人原创，转载请注明作者和出处。   在上一章我们分析了Okhttp分发器对同步&#x2F;异步请求的处理，本章将和大家一起分析Okhttp的最核心模块–拦截链的代码。在这里你将会了解到Okhttp究竟如何处理请求的。  系列文章索引：OkHttp源码学习系列一：总流程和Dispatcher分析OkHttp源码学习系列二：拦截链分析OkHttp源码学习系列三：缓存总结 ###零、拦截链总流程上一章我">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-05-18T13:20:10.000Z">
<meta property="article:modified_time" content="2020-12-24T11:34:17.239Z">
<meta property="article:author" content="业松">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="OKHttp">
<meta property="article:tag" content="源码分析">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="业松 Studio" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">业松 Studio</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-OkHttp源码学习系列二：拦截链分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/18/OkHttp%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E6%8B%A6%E6%88%AA%E9%93%BE%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2018-05-18T13:20:10.000Z" itemprop="datePublished">2018-05-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      OkHttp源码学习系列二：拦截链分析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文为本人原创，转载请注明作者和出处。</p>
</blockquote>
<blockquote>
<p>在上一章我们分析了Okhttp分发器对同步/异步请求的处理，本章将和大家一起分析Okhttp的最核心模块–拦截链的代码。在这里你将会了解到Okhttp究竟如何处理请求的。</p>
</blockquote>
<p>系列文章索引：<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/425695e3ae03">OkHttp源码学习系列一：总流程和Dispatcher分析</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/41a5d45085b4">OkHttp源码学习系列二：拦截链分析</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8928f4b128f1">OkHttp源码学习系列三：缓存总结</a></p>
<p>###零、拦截链总流程<br>上一章我们分析到了RealCall的getResponseWithInterceptorChain方法，现在我们继续，先来看下这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">    &#x2F;&#x2F; Build a full stack of interceptors.</span><br><span class="line">    List&lt;Interceptor&gt; interceptors &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">    interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">    if (!forWebSocket) &#123;</span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line">    </span><br><span class="line">    Interceptor.Chain chain &#x3D; new RealInterceptorChain(</span><br><span class="line">        interceptors, null, null, null, 0, originalRequest);</span><br><span class="line">    return chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>可以看到这个方法前面一大堆都很简单，new了一个存放拦截器的数组。这个Interceptor是接口，后面添加的各个元素都是它的实现类。这里先添加了okhttpClient对象里的拦截器，这里是用户自定义的拦截器，全都会在这里添加进去。然后一次添加retryAndFollowUpInterceptor，BridgeInterceptor，CacheInterceptor，ConnectInterceptor，CallServerInterceptor五个拦截器，其中在倒数第二的位置上，如果上websocket连接，还会额外添加networkInterceptor拦截器组。这里的添加顺序要注意，后面我们会看到，拦截器的拦截顺序也是和添加顺序是一致的。</p>
<p>添加完成后，执行了RealInterceptorChain也就是拦截器链的proceed方法，传入原始request。其实拦截器链我们看名字大致能猜到，它会将各个拦截器串起来，像链条一样依次去拦截或者说加工request，最终得到response后，依次再向上返回，各个拦截器再依次处理response，最终返回给用户。现在我们来看下proceed方法是如何串起各个拦截器的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Call the next interceptor in the chain.</span><br><span class="line">RealInterceptorChain next &#x3D; new RealInterceptorChain(</span><br><span class="line">    interceptors, streamAllocation, httpCodec, connection, index + 1, request);</span><br><span class="line">Interceptor interceptor &#x3D; interceptors.get(index);</span><br><span class="line">Response response &#x3D; interceptor.intercept(next);</span><br></pre></td></tr></table></figure>
<p>源代码有点长，这里我们略去各种异常判断，只看核心的这段代码。看源码的时候一定要记得抓住主脉络，因为我们不可能一次弄明白或记住所有的源码细节。抓住重点，才不会只见树木，不见森林。<br>在这里它又重复创建了一个RealInterceptorChain对象，只是对index做了+1处理。这个index就是记录interceptors拦截器数组的角标的。之后会从数组中取出当前的拦截器，调用intercept方法并传入这个新new出来的RealInterceptorChain，得到response并返回。</p>
<p>看到这里可能有点懵，直觉告诉我们应该只要一个RealInterceptorChain对象去管理所有拦截器，然而这里似乎没拦截一次都会产生一个新的RealInterceptorChain，只不过把拦截器数组的角标index往后移了一位。不要着急，我们看了这里关键的拦截方法intercept就可以知道是怎么一回事了。这是个抽象方法，它的所有实现，都会调用chain.proceed(request)这句代码，包括我们自己自定义的拦截器，在intercept方法中我们也必须调用这句方法才能生效。在后面的贴出来的代码中大家也都会看到这句代码。这个方法仿佛之前见过？是的没错，在getResponseWithInterceptorChain中我们第一次new拦截器链对象就调用了该方法。这里又调用了该方法，只是这里的拦截器对象是我们新new出来的，index+1的拦截器链。于是乎在这次调用中，又会new出一个新的拦截器链对象，并会根据index取出下一个拦截器，执行该拦截器的intercept方法。如此递归调用，直至拦截器数组中没有下一个拦截器，得到response并向上传递。</p>
<p>可以看到这里的拦截链使用的非常巧妙，有点像栈的数据结构。依次将各个拦截器的方法入栈，最后得到response，再依次弹栈。如果是我来写的话，可能就直接一个for循环依次调用每个拦截器的拦截方法。但是这样的话我还得再来一遍反循环，再来依次处理加工response。很明显这里栈的结构更符合我们的业务场景。</p>
<p>###一、RetryAndFollowUpInterceptor<br>下面我们来看第一个拦截器RetryAndFollowUpInterceptor，看名字可以猜到这个拦截器是负责失败重连和重定向的拦截器。</p>
<p>直接来看它的intercept方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    Request request &#x3D; chain.request();</span><br><span class="line">    </span><br><span class="line">    streamAllocation &#x3D; new StreamAllocation(</span><br><span class="line">        client.connectionPool(), createAddress(request.url()), callStackTrace);</span><br><span class="line">    </span><br><span class="line">    int followUpCount &#x3D; 0;</span><br><span class="line">    Response priorResponse &#x3D; null;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">      if (canceled) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      Response response &#x3D; null;</span><br><span class="line">      boolean releaseConnection &#x3D; true;</span><br><span class="line">      try &#123;</span><br><span class="line">        response &#x3D; ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);</span><br><span class="line">        releaseConnection &#x3D; false;</span><br><span class="line">      &#125; catch (RouteException e) &#123;</span><br><span class="line">        &#x2F;&#x2F; The attempt to connect via a route failed. The request will not have been sent.</span><br><span class="line">        if (!recover(e.getLastConnectException(), false, request)) &#123;</span><br><span class="line">          throw e.getLastConnectException();</span><br><span class="line">        &#125;</span><br><span class="line">        releaseConnection &#x3D; false;</span><br><span class="line">        continue;</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">        &#x2F;&#x2F; An attempt to communicate with a server failed. The request may have been sent.</span><br><span class="line">        boolean requestSendStarted &#x3D; !(e instanceof ConnectionShutdownException);</span><br><span class="line">        if (!recover(e, requestSendStarted, request)) throw e;</span><br><span class="line">        releaseConnection &#x3D; false;</span><br><span class="line">        continue;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; We&#39;re throwing an unchecked exception. Release any resources.</span><br><span class="line">        if (releaseConnection) &#123;</span><br><span class="line">          streamAllocation.streamFailed(null);</span><br><span class="line">          streamAllocation.release();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      &#x2F;&#x2F; Attach the prior response if it exists. Such responses never have a body.</span><br><span class="line">      if (priorResponse !&#x3D; null) &#123;</span><br><span class="line">        response &#x3D; response.newBuilder()</span><br><span class="line">            .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                    .body(null)</span><br><span class="line">                    .build())</span><br><span class="line">            .build();</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      Request followUp &#x3D; followUpRequest(response);</span><br><span class="line">    </span><br><span class="line">      if (followUp &#x3D;&#x3D; null) &#123;</span><br><span class="line">        if (!forWebSocket) &#123;</span><br><span class="line">          streamAllocation.release();</span><br><span class="line">        &#125;</span><br><span class="line">        return response;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      closeQuietly(response.body());</span><br><span class="line">    </span><br><span class="line">      if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      if (followUp.body() instanceof UnrepeatableRequestBody) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code());</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      if (!sameConnection(response, followUp.url())) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">        streamAllocation &#x3D; new StreamAllocation(</span><br><span class="line">            client.connectionPool(), createAddress(followUp.url()), callStackTrace);</span><br><span class="line">      &#125; else if (streamAllocation.codec() !&#x3D; null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Closing the body of &quot; + response</span><br><span class="line">            + &quot; didn&#39;t close its backing stream. Bad interceptor?&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      request &#x3D; followUp;</span><br><span class="line">      priorResponse &#x3D; response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的代码非常长，但是又不太好精简我就都贴上来了。不要害怕，还是比较容易理顺的。首先它new了一个StreamAllocation对象，这个对象封装了RealConnection、RouteSelector、HttpCodec等http连接要用到的重要对象，有兴趣的同学可以看看这部分源码，这里不展开讲它，只要知道这是个http连接必须要用到的重要资源对象。</p>
<p>之后定义了followUpCount也就是重连次数，以及一个空的response。紧接着就是一个while(true)死循环。这个死循环不用看也能想到，肯定是不断的进行重连/重定向的。核心代码是这句response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null)，是的，所谓的重连就是重复调用下一个拦截器继续拦截。这里和第一次在RealCall中的调用不一样的地方是传入了streamAllocation给下一个拦截器链，之前传的是null。</p>
<p>那么这个死循环如何结束呢？这里除了获得response后的且没有重定向得return，好像没找到其他退出循环的地方。是不是没有response之前会一直重复请求直到有结果呢？这明显不肯能，这里是通过抛异常的方式来结束重连。我们来看抛异常的地方有哪些：</p>
<ul>
<li><ol>
<li>当前请求被cancel的时候</li>
</ol>
</li>
<li><ol start="2">
<li>重连次数超过上限（默认是20，用户可修改）</li>
</ol>
</li>
<li><ol start="3">
<li>重定向的请求体属于不能重复的请求体</li>
</ol>
</li>
<li><ol start="4">
<li>没有正确释放streamAllocation内的codec</li>
</ol>
</li>
</ul>
<p>除了最后一条，其他时候都会调用streamAllocation.release()来释放资源。另外，这里还有一处要点是调用了followUpRequest方法进行重定向。这个方法非常长，这里简单讲下是干嘛的：先获得传入的响应体的code，根据不同的code去构建不同的request进行重定向。如果不需要重定向，直接返回null，如果是301、302这样的重定向响应码，使用重定向的url重新构建request，在上面的死循环中重新进行请求。</p>
<p>到这里RetryAndFollowUpInterceptor就讲的差不多了，它主要负责的任务就是失败重连，和重定向重新构建request重连，是不是还挺简单的？</p>
<p>###二、BridgeInterceptor<br>BridgeInterceptor是五个拦截器中最简单的一个了，它做的事情很简单，正如其名字，它是一个连接网络数据流和我们程序能用的request、response对象的桥梁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">   Request userRequest &#x3D; chain.request();</span><br><span class="line">   Request.Builder requestBuilder &#x3D; userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line">   RequestBody body &#x3D; userRequest.body();</span><br><span class="line">   if (body !&#x3D; null) &#123;</span><br><span class="line">     MediaType contentType &#x3D; body.contentType();</span><br><span class="line">     if (contentType !&#x3D; null) &#123;</span><br><span class="line">       requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     long contentLength &#x3D; body.contentLength();</span><br><span class="line">     if (contentLength !&#x3D; -1) &#123;</span><br><span class="line">       requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));</span><br><span class="line">       requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);</span><br><span class="line">       requestBuilder.removeHeader(&quot;Content-Length&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (userRequest.header(&quot;Host&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">     requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (userRequest.header(&quot;Connection&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">     requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; If we add an &quot;Accept-Encoding: gzip&quot; header field we&#39;re responsible for also decompressing</span><br><span class="line">   &#x2F;&#x2F; the transfer stream.</span><br><span class="line">   boolean transparentGzip &#x3D; false;</span><br><span class="line">   if (userRequest.header(&quot;Accept-Encoding&quot;) &#x3D;&#x3D; null &amp;&amp; userRequest.header(&quot;Range&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">     transparentGzip &#x3D; true;</span><br><span class="line">     requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   List&lt;Cookie&gt; cookies &#x3D; cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">   if (!cookies.isEmpty()) &#123;</span><br><span class="line">     requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (userRequest.header(&quot;User-Agent&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">     requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Response networkResponse &#x3D; chain.proceed(requestBuilder.build());</span><br><span class="line"></span><br><span class="line">   HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">   Response.Builder responseBuilder &#x3D; networkResponse.newBuilder()</span><br><span class="line">       .request(userRequest);</span><br><span class="line"></span><br><span class="line">   if (transparentGzip</span><br><span class="line">       &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))</span><br><span class="line">       &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">     GzipSource responseBody &#x3D; new GzipSource(networkResponse.body().source());</span><br><span class="line">     Headers strippedHeaders &#x3D; networkResponse.headers().newBuilder()</span><br><span class="line">         .removeAll(&quot;Content-Encoding&quot;)</span><br><span class="line">         .removeAll(&quot;Content-Length&quot;)</span><br><span class="line">         .build();</span><br><span class="line">     responseBuilder.headers(strippedHeaders);</span><br><span class="line">     responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return responseBuilder.build();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它将我们传入的request新增了好几个请求头，这就是为什么我们平时使用的时候即使完全不加请求头，抓出来的包依然有好多请求头。这里要注意一下“Keep-Alive”，这个请求头是告诉服务器，在请求完成后不要断开连接。我们知道http是短链接，为什么okhttp还要默认加这么个请求头呢？这是为了复用连接，当再次发起相同请求的时候，可以节省再次开启连接的消耗。</p>
<p>当得到response的时候，如果http连接使用了gzip压缩，会对响应流进行gzip解压缩，因此我们自己在使用的时候完全不需要再做这些操作。</p>
<p>###三、CacheInterceptor<br>CacheInterceptor顾名思义，是负责缓存相关处理的一个拦截器。由于在下一章我会专门讲okhttp的缓存机制，这里有些细节我会先跳过。它的intercept代码非常长，而且每一段都要分析，所以我分开来一段一段地分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Response cacheCandidate &#x3D; cache !&#x3D; null</span><br><span class="line">    ? cache.get(chain.request())</span><br><span class="line">    : null;</span><br><span class="line"></span><br><span class="line">long now &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">CacheStrategy strategy &#x3D; new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">Request networkRequest &#x3D; strategy.networkRequest;</span><br><span class="line">Response cacheResponse &#x3D; strategy.cacheResponse;</span><br></pre></td></tr></table></figure>
<p>首先从cache对象根据当前的request取出缓存的response命名为cacheCandidate，也就是候选的缓存，不一定会使用。之后使用当前时间、request和候选缓存构建出了一个CacheStrategy对象，这个对象是负责缓存策略实施的。它会根据不同的请求码、响应码返回不同的networkRequest和cacheResponse。这个类会放到下一章展开讨论，目前我们只要知道，它会根据request和cacheCandidate返回networkRequest（实际要进行网络请求的request）以及cacheResponse（缓存的response）。如果networkRequest为null（比如requset中含有only-if-cached请求头的时候），表示不进行网络请求。当cacheResponse为null的时候，说明没有缓存，或者当前缓存过期或者当前缓存策略不允许使用缓存等，总之就代表无缓存可用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (cache !&#x3D; null) &#123;</span><br><span class="line">  cache.trackResponse(strategy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (cacheCandidate !&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">  closeQuietly(cacheCandidate.body()); &#x2F;&#x2F; The cache candidate wasn&#39;t applicable. Close it.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Cache的trackResponse是起计数作用的，不是重点。下面一个判断如果cacheCandidate不为null代表我们取到了缓存，cacheResponse为null代表这个缓存过期或者由于缓存策略等原因用不了，那么这个cacheCandidate没有用了，我门需要关闭它的流。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; If we&#39;re forbidden from using the network and the cache is insufficient, fail.</span><br><span class="line">if (networkRequest &#x3D;&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">  return new Response.Builder()</span><br><span class="line">      .request(chain.request())</span><br><span class="line">      .protocol(Protocol.HTTP_1_1)</span><br><span class="line">      .code(504)</span><br><span class="line">      .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">      .body(Util.EMPTY_RESPONSE)</span><br><span class="line">      .sentRequestAtMillis(-1L)</span><br><span class="line">      .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; If we don&#39;t need the network, we&#39;re done.</span><br><span class="line">if (networkRequest &#x3D;&#x3D; null) &#123;</span><br><span class="line">  return cacheResponse.newBuilder()</span><br><span class="line">      .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面说过了networkRequest为null代表我们将不进行网络请求，这时候分为两种情况。如果cacheResponse也为null说明我们没有有效的缓存response，而我们又不会进行网络请求，因此给上层构建了一个响应码味504的response。如果cacheResponse不为null，说明我们有可用缓存，而此次请求又不会再请求网络，因此直接将缓存response返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Response networkResponse &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">  networkResponse &#x3D; chain.proceed(networkRequest);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  &#x2F;&#x2F; If we&#39;re crashing on I&#x2F;O or otherwise, don&#39;t leak the cache body.</span><br><span class="line">  if (networkResponse &#x3D;&#x3D; null &amp;&amp; cacheCandidate !&#x3D; null) &#123;</span><br><span class="line">    closeQuietly(cacheCandidate.body());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; If we have a cache response too, then we&#39;re doing a conditional get.</span><br><span class="line">if (cacheResponse !&#x3D; null) &#123;</span><br><span class="line">  if (networkResponse.code() &#x3D;&#x3D; HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">    Response response &#x3D; cacheResponse.newBuilder()</span><br><span class="line">        .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">        .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">        .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build();</span><br><span class="line">    networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Update the cache after combining headers but before stripping the</span><br><span class="line">    &#x2F;&#x2F; Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">    cache.trackConditionalCacheHit();</span><br><span class="line">    cache.update(cacheResponse, response);</span><br><span class="line">    return response;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    closeQuietly(cacheResponse.body());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面networkRequest为null也就是不进行网络请求的情况我们已经全部处理了，下面必须要进行网络请求了，调用拦截链的proceed方法让后面的拦截器去请求网络数据得到response。如果cacheResponse不为null，那么此时我们有两个response：一个是缓存的，一个是网络请求返回的，此时我们需要处理到底使用哪个。此时如果服务器返回的响应码为HTTP_NOT_MODIFIED，也就是我们常见的304，代表服务器的资源没有变化，客户端去取本地缓存即可，此时服务器不会返回响应体。那么这个时候我们会使用缓存的cacheResponse构建一个新的response并返回。同时我们会记录这次我们的cache命中了，因为okhttp默认使用了LruCache算法，Least Recently Used最近最少使用原则，需要我们在使用的时候计数。同时把新构建的response刷新到缓存中去。当然了，如果没有返回304，说明缓存已经过期，我们需要将它的流关闭。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Response response &#x3D; networkResponse.newBuilder()</span><br><span class="line">    .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">    .networkResponse(stripBody(networkResponse))</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">if (cache !&#x3D; null) &#123;</span><br><span class="line">  if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">    &#x2F;&#x2F; Offer this request to the cache.</span><br><span class="line">    CacheRequest cacheRequest &#x3D; cache.put(response);</span><br><span class="line">    return cacheWritingResponse(cacheRequest, response);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      cache.remove(networkRequest);</span><br><span class="line">    &#125; catch (IOException ignored) &#123;</span><br><span class="line">      &#x2F;&#x2F; The cache cannot be written.</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return response;</span><br></pre></td></tr></table></figure>
<p>最后剩下来的情况就是缓存过期，我们需要使用网络返回的response这种情况。直接使用networkResponse构建response并返回。此时我们还需要做一件事，就是更新我们的缓存，将最终response写入到cache对象中去。但此时如果我们的请求方式不支持缓存（常见的两种请求方式，get请求支持缓存，post不支持），我们不但不能更新缓存，还要将缓存删掉。</p>
<p>至此，缓存拦截器也讲的差不多了，在下一章我将会进一步讲解okhttp的缓存策略实现。</p>
<p>###四、ConnectInterceptor<br>经历过前面三个拦截器的处理，我们发现目前为止我们还没有进行真正的请求。别急，ConnectInterceptor就是一个负责建立http连接的拦截器。它的intercept代码不多，赶紧来看下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    RealInterceptorChain realChain &#x3D; (RealInterceptorChain) chain;</span><br><span class="line">    Request request &#x3D; realChain.request();</span><br><span class="line">    StreamAllocation streamAllocation &#x3D; realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; We need the network to satisfy this request. Possibly for validating a conditional GET.</span><br><span class="line">    boolean doExtensiveHealthChecks &#x3D; !request.method().equals(&quot;GET&quot;);</span><br><span class="line">    HttpCodec httpCodec &#x3D; streamAllocation.newStream(client, doExtensiveHealthChecks);</span><br><span class="line">    RealConnection connection &#x3D; streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">    return realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常简短是不是，它只做了两件事，一是生成HttpCodec对象，该对象是给http请求/响应编码、解码的。另外还调用了streamAllocation.connection方法取出RealConnection连接对象。但是取出connection对象后，我找了半天没找到在哪建立连接的，最后发现其实是在streamAllocation.newStream()方法中建立的，来看看这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) &#123;</span><br><span class="line">    int connectTimeout &#x3D; client.connectTimeoutMillis();</span><br><span class="line">    int readTimeout &#x3D; client.readTimeoutMillis();</span><br><span class="line">    int writeTimeout &#x3D; client.writeTimeoutMillis();</span><br><span class="line">    boolean connectionRetryEnabled &#x3D; client.retryOnConnectionFailure();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      RealConnection resultConnection &#x3D; findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class="line">      HttpCodec resultCodec &#x3D; resultConnection.newCodec(client, this);</span><br><span class="line"></span><br><span class="line">      synchronized (connectionPool) &#123;</span><br><span class="line">        codec &#x3D; resultCodec;</span><br><span class="line">        return resultCodec;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      throw new RouteException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里从okhttpclient中取出了一些连接参数，调用了findHealthyConnection方法获得连接，并且通过这个RealConnection对象创建了此次请求的HttpCodec对象。点进来看看findHealthyConnection方法,该方法是个无限循环，直到findConnection方法找到健康的连接，直接看findConnection方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,</span><br><span class="line">    boolean connectionRetryEnabled) throws IOException &#123;</span><br><span class="line">  Route selectedRoute;</span><br><span class="line">  synchronized (connectionPool) &#123;</span><br><span class="line">    if (released) throw new IllegalStateException(&quot;released&quot;);</span><br><span class="line">    if (codec !&#x3D; null) throw new IllegalStateException(&quot;codec !&#x3D; null&quot;);</span><br><span class="line">    if (canceled) throw new IOException(&quot;Canceled&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Attempt to use an already-allocated connection.</span><br><span class="line">    RealConnection allocatedConnection &#x3D; this.connection;</span><br><span class="line">    if (allocatedConnection !&#x3D; null &amp;&amp; !allocatedConnection.noNewStreams) &#123;</span><br><span class="line">      return allocatedConnection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Attempt to get a connection from the pool.</span><br><span class="line">    Internal.instance.get(connectionPool, address, this, null);</span><br><span class="line">    if (connection !&#x3D; null) &#123;</span><br><span class="line">      return connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    selectedRoute &#x3D; route;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; If we need a route, make one. This is a blocking operation.</span><br><span class="line">  if (selectedRoute &#x3D;&#x3D; null) &#123;</span><br><span class="line">    selectedRoute &#x3D; routeSelector.next();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  RealConnection result;</span><br><span class="line">  synchronized (connectionPool) &#123;</span><br><span class="line">    if (canceled) throw new IOException(&quot;Canceled&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Now that we have an IP address, make another attempt at getting a connection from the pool.</span><br><span class="line">    &#x2F;&#x2F; This could match due to connection coalescing.</span><br><span class="line">    Internal.instance.get(connectionPool, address, this, selectedRoute);</span><br><span class="line">    if (connection !&#x3D; null) &#123;</span><br><span class="line">      route &#x3D; selectedRoute;</span><br><span class="line">      return connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Create a connection and assign it to this allocation immediately. This makes it possible</span><br><span class="line">    &#x2F;&#x2F; for an asynchronous cancel() to interrupt the handshake we&#39;re about to do.</span><br><span class="line">    route &#x3D; selectedRoute;</span><br><span class="line">    refusedStreamCount &#x3D; 0;</span><br><span class="line">    result &#x3D; new RealConnection(connectionPool, selectedRoute);</span><br><span class="line">    acquire(result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Do TCP + TLS handshakes. This is a blocking operation.</span><br><span class="line">  result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);</span><br><span class="line">  routeDatabase().connected(result.route());</span><br><span class="line"></span><br><span class="line">  Socket socket &#x3D; null;</span><br><span class="line">  synchronized (connectionPool) &#123;</span><br><span class="line">    &#x2F;&#x2F; Pool the connection.</span><br><span class="line">    Internal.instance.put(connectionPool, result);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If another multiplexed connection to the same address was created concurrently, then</span><br><span class="line">    &#x2F;&#x2F; release this connection and acquire that one.</span><br><span class="line">    if (result.isMultiplexed()) &#123;</span><br><span class="line">      socket &#x3D; Internal.instance.deduplicate(connectionPool, address, this);</span><br><span class="line">      result &#x3D; connection;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  closeQuietly(socket);</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又是一个比较长的方法。前半段是在尝试寻找connection，最开始寻找是否有可以复用的已经建立好连接并且空闲的connection。没有的话继续从连接池里取，如果连接池里没有，就需要new一个connection并加入连接池。有了connection对象后，终于可以调用其connect方法真正进行连接啦！看注释可以知道，这里的connect方法进行了TCP + TLS握手操作，是个阻塞操作。同时这里还会判断下连接是否multiplexed，也就是和当前某个已有的连接重复了，如果重复的话会释放该连接。已经到这步了，当然要看看connect方法是怎样建立连接的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public void connect(</span><br><span class="line">    int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) &#123;</span><br><span class="line">  if (protocol !&#x3D; null) throw new IllegalStateException(&quot;already connected&quot;);</span><br><span class="line"></span><br><span class="line">  RouteException routeException &#x3D; null;</span><br><span class="line">  List&lt;ConnectionSpec&gt; connectionSpecs &#x3D; route.address().connectionSpecs();</span><br><span class="line">  ConnectionSpecSelector connectionSpecSelector &#x3D; new ConnectionSpecSelector(connectionSpecs);</span><br><span class="line"></span><br><span class="line">  if (route.address().sslSocketFactory() &#x3D;&#x3D; null) &#123;</span><br><span class="line">    if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) &#123;</span><br><span class="line">      throw new RouteException(new UnknownServiceException(</span><br><span class="line">          &quot;CLEARTEXT communication not enabled for client&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    String host &#x3D; route.address().url().host();</span><br><span class="line">    if (!Platform.get().isCleartextTrafficPermitted(host)) &#123;</span><br><span class="line">      throw new RouteException(new UnknownServiceException(</span><br><span class="line">          &quot;CLEARTEXT communication to &quot; + host + &quot; not permitted by network security policy&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  while (true) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      if (route.requiresTunnel()) &#123;</span><br><span class="line">        connectTunnel(connectTimeout, readTimeout, writeTimeout);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        connectSocket(connectTimeout, readTimeout);</span><br><span class="line">      &#125;</span><br><span class="line">      establishProtocol(connectionSpecSelector);</span><br><span class="line">      break;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      closeQuietly(socket);</span><br><span class="line">      closeQuietly(rawSocket);</span><br><span class="line">      socket &#x3D; null;</span><br><span class="line">      rawSocket &#x3D; null;</span><br><span class="line">      source &#x3D; null;</span><br><span class="line">      sink &#x3D; null;</span><br><span class="line">      handshake &#x3D; null;</span><br><span class="line">      protocol &#x3D; null;</span><br><span class="line">      http2Connection &#x3D; null;</span><br><span class="line"></span><br><span class="line">      if (routeException &#x3D;&#x3D; null) &#123;</span><br><span class="line">        routeException &#x3D; new RouteException(e);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        routeException.addConnectException(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) &#123;</span><br><span class="line">        throw routeException;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (http2Connection !&#x3D; null) &#123;</span><br><span class="line">    synchronized (connectionPool) &#123;</span><br><span class="line">      allocationLimit &#x3D; http2Connection.maxConcurrentStreams();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里的代码比较接近底层了，本人看起来也是十分吃力。首先它会判断Protocol对象是否为null，Protocol是封装的通信协议对象，如果已经存在，则表明已连接。然后会根据路由地址获取connectionSpecs集合，ConnectionSpec点进去看了下是更一步的有TLS协议的连接。之后判断如果TLS协议不合格，会抛RouteException不进行连接。这也从一方面解释了okhttp为什么强调它是一个很安全的http框架。</p>
<p>紧接着是一个无限循环进行连接，调用establishProtocol建立真正的Client-Server通信，这个方法会抛出IO异常。如果顺利的话跳出循环，有异常的话会根据情况是否抛异常放弃连接还是继续尝试下一次连接。最后还会对http流的数量做一个限制。</p>
<p>继续往下看的话establishProtocol方法会调用connectTls方法进行三次握手操作，与https有关的ssl认证过程就在其中，限于篇幅就不仔细讲了。最终会调用Http2Connection对象的start方法开启连接。这个过程的细节非常多，由于我们重点是讲拦截器的，这里就此打住。以后有机会的再开一篇文章专门讲这里的代码。</p>
<p>###CallServerInterceptor<br>这是okhttp网络请求的最后一个拦截器，ConnectInterceptor是负责建立http连接的，而它负责真正向服务器发起请求。直接看它的intercept代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RealInterceptorChain realChain &#x3D; (RealInterceptorChain) chain;</span><br><span class="line">HttpCodec httpCodec &#x3D; realChain.httpStream();</span><br><span class="line">StreamAllocation streamAllocation &#x3D; realChain.streamAllocation();</span><br><span class="line">RealConnection connection &#x3D; (RealConnection) realChain.connection();</span><br><span class="line">Request request &#x3D; realChain.request();</span><br><span class="line"></span><br><span class="line">long sentRequestMillis &#x3D; System.currentTimeMillis();</span><br><span class="line">httpCodec.writeRequestHeaders(request);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先获取HttpCodec和RealConnection连接对象，通过HttpCodec编码最终的请求头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Response.Builder responseBuilder &#x3D; null;</span><br><span class="line">if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() !&#x3D; null) &#123;</span><br><span class="line">  &#x2F;&#x2F; If there&#39;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP&#x2F;1.1 100</span><br><span class="line">  &#x2F;&#x2F; Continue&quot; response before transmitting the request body. If we don&#39;t get that, return what</span><br><span class="line">  &#x2F;&#x2F; we did get (such as a 4xx response) without ever transmitting the request body.</span><br><span class="line">  if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) &#123;</span><br><span class="line">    httpCodec.flushRequest();</span><br><span class="line">    responseBuilder &#x3D; httpCodec.readResponseHeaders(true);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (responseBuilder &#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span><br><span class="line">    Sink requestBodyOut &#x3D; httpCodec.createRequestBody(request, request.body().contentLength());</span><br><span class="line">    BufferedSink bufferedRequestBody &#x3D; Okio.buffer(requestBodyOut);</span><br><span class="line">    request.body().writeTo(bufferedRequestBody);</span><br><span class="line">    bufferedRequestBody.close();</span><br><span class="line">  &#125; else if (!connection.isMultiplexed()) &#123;</span><br><span class="line">    &#x2F;&#x2F; If the &quot;Expect: 100-continue&quot; expectation wasn&#39;t met, prevent the HTTP&#x2F;1 connection from</span><br><span class="line">    &#x2F;&#x2F; being reused. Otherwise we&#39;re still obligated to transmit the request body to leave the</span><br><span class="line">    &#x2F;&#x2F; connection in a consistent state.</span><br><span class="line">    streamAllocation.noNewStreams();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码则是编码请求体的，首先判断下请求方法是否支持请求体（比如get请求就没有请求体），然后通过HttpCodec编码最终的请求体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">httpCodec.finishRequest();</span><br><span class="line"></span><br><span class="line">if (responseBuilder &#x3D;&#x3D; null) &#123;</span><br><span class="line">  responseBuilder &#x3D; httpCodec.readResponseHeaders(false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response response &#x3D; responseBuilder</span><br><span class="line">    .request(request)</span><br><span class="line">    .handshake(streamAllocation.connection().handshake())</span><br><span class="line">    .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">    .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">int code &#x3D; response.code();</span><br><span class="line">if (forWebSocket &amp;&amp; code &#x3D;&#x3D; 101) &#123;</span><br><span class="line">  &#x2F;&#x2F; Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span><br><span class="line">  response &#x3D; response.newBuilder()</span><br><span class="line">      .body(Util.EMPTY_RESPONSE)</span><br><span class="line">      .build();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  response &#x3D; response.newBuilder()</span><br><span class="line">      .body(httpCodec.openResponseBody(response))</span><br><span class="line">      .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;))</span><br><span class="line">    || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) &#123;</span><br><span class="line">  streamAllocation.noNewStreams();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ((code &#x3D;&#x3D; 204 || code &#x3D;&#x3D; 205) &amp;&amp; response.body().contentLength() &gt; 0) &#123;</span><br><span class="line">  throw new ProtocolException(</span><br><span class="line">      &quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return response;</span><br></pre></td></tr></table></figure>
<p>最终的requst完成后，通过HttpCodec读取响应头和响应体并进行解码，构建最终的response。其中如果响应码为101（表明要升级协议），则返回一个空的response。204或205（表明响应体没有内容）但响应体长度缺不为0则抛异常。如果Connection响应头为close，表明请求完毕，需要关闭流。</p>
<p>最终将response逐层向上返回，经过所有拦截器的处理后返回给用户。</p>
<p>终于写完了，限于我的知识水平有限，有错误的地方请大家及时纠正，感谢您的阅读！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/18/OkHttp%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%BA%8C%EF%BC%9A%E6%8B%A6%E6%88%AA%E9%93%BE%E5%88%86%E6%9E%90/" data-id="ckj2v1srg0059bkus9ao5b1zh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OKHttp/" rel="tag">OKHttp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/07/21/OkHttp%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%89%EF%BC%9A%E7%BC%93%E5%AD%98%E6%80%BB%E7%BB%93/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          OkHttp源码学习系列三：缓存总结
        
      </div>
    </a>
  
  
    <a href="/2018/05/10/OkHttp%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%9A%E6%80%BB%E6%B5%81%E7%A8%8B%E5%92%8CDispatcher%E5%88%86%E6%9E%90/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">OkHttp源码学习系列一：总流程和Dispatcher分析</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/">Node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%88%AC%E8%99%AB/">爬虫</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/">项目管理</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-Studio/" rel="tag">Android Studio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Github/" rel="tag">Github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JPA/" rel="tag">JPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Koa/" rel="tag">Koa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/" rel="tag">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/" rel="tag">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OKHttp/" rel="tag">OKHttp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Profiler/" rel="tag">Profiler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Boot/" rel="tag">Spring Boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/" rel="tag">Ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ava/" rel="tag">ava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongoose/" rel="tag">mongoose</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%88%AC%E8%99%AB/" rel="tag">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" rel="tag">环境配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%9F%E6%B4%BB/" rel="tag">生活</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/" rel="tag">职业规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" rel="tag">项目管理</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Android-Studio/" style="font-size: 12.5px;">Android Studio</a> <a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/JPA/" style="font-size: 10px;">JPA</a> <a href="/tags/JVM/" style="font-size: 12.5px;">JVM</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Koa/" style="font-size: 10px;">Koa</a> <a href="/tags/Kotlin/" style="font-size: 12.5px;">Kotlin</a> <a href="/tags/Linux/" style="font-size: 12.5px;">Linux</a> <a href="/tags/MongoDB/" style="font-size: 10px;">MongoDB</a> <a href="/tags/Node-js/" style="font-size: 15px;">Node.js</a> <a href="/tags/OKHttp/" style="font-size: 15px;">OKHttp</a> <a href="/tags/Profiler/" style="font-size: 10px;">Profiler</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/Spring-Boot/" style="font-size: 10px;">Spring Boot</a> <a href="/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a> <a href="/tags/ava/" style="font-size: 10px;">ava</a> <a href="/tags/git/" style="font-size: 12.5px;">git</a> <a href="/tags/mongoose/" style="font-size: 10px;">mongoose</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 10px;">性能优化</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 15px;">源码分析</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 10px;">爬虫</a> <a href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" style="font-size: 15px;">环境配置</a> <a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size: 12.5px;">生活</a> <a href="/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/" style="font-size: 10px;">职业规划</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 17.5px;">随笔</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" style="font-size: 10px;">项目管理</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/12/24/%E8%80%81%E5%AE%9E%E4%BA%BA%E6%80%95%E5%BC%80%E5%8F%A3/">老实人怕开口</a>
          </li>
        
          <li>
            <a href="/2019/01/01/2019%E7%AC%AC%E4%B8%80%E5%A4%A9%E5%85%88%E7%AB%8Bflag/">2019第一天先立flag</a>
          </li>
        
          <li>
            <a href="/2018/12/31/2018%E7%BB%99%E8%87%AA%E5%B7%B1%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%80%BB%E7%BB%93/">2018给自己一个简单的总结</a>
          </li>
        
          <li>
            <a href="/2018/12/29/%E4%BD%BF%E7%94%A8jsonwebtoken%E5%AE%8C%E6%88%90nodejs%E7%9A%84%E7%99%BB%E9%99%86%E7%B3%BB%E7%BB%9F/">使用jsonwebtoken完成nodejs的登陆系统</a>
          </li>
        
          <li>
            <a href="/2018/12/28/Android%E4%B8%89%E5%A4%A7%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84MVC%E3%80%81MVP%E3%80%81MVVM%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/">Android三大项目架构MVC、MVP、MVVM使用体验</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 业松<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>