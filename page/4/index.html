<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>业松 Studio</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="业松的个人博客，主要有android，java，angular，个人散文等博客">
<meta property="og:type" content="website">
<meta property="og:title" content="业松 Studio">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="业松 Studio">
<meta property="og:description" content="业松的个人博客，主要有android，java，angular，个人散文等博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="业松">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="业松 Studio" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">业松 Studio</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-魔都，认真告别每一个过客" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/24/%E9%AD%94%E9%83%BD%EF%BC%8C%E8%AE%A4%E7%9C%9F%E5%91%8A%E5%88%AB%E6%AF%8F%E4%B8%80%E4%B8%AA%E8%BF%87%E5%AE%A2/" class="article-date">
  <time datetime="2017-07-24T08:13:27.000Z" itemprop="datePublished">2017-07-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/24/%E9%AD%94%E9%83%BD%EF%BC%8C%E8%AE%A4%E7%9C%9F%E5%91%8A%E5%88%AB%E6%AF%8F%E4%B8%80%E4%B8%AA%E8%BF%87%E5%AE%A2/">魔都，认真告别每一个过客</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文为作者原创，转载请注明作者和原文地址</p>
</blockquote>
<blockquote>
<p>记得小学的时候，虽然自己没转过学，但是有过好多小伙伴转学而离开。时至今日，我也无法描述这种离别的复杂感情。</p>
</blockquote>
<p>今天，来到上海后第三次换房子。告别了之前一起合租差不多五个月的基友，现在是一个人住了，暂且叫他阿文吧。上大学的时候觉得集体宿舍人太多，没有个人隐私空间，有时候很羡慕搬出去住的同学，向往他们的独居生活。</p>
<p>工作以后，离开北京，先后在深圳和上海讨生活。和学生时代不同，工作以后在北上广深这种大城市，越发觉得自己渺小。而伴随着换工作-&gt;告别旧的朋友同事-&gt;认识新的朋友同事这种节奏，越发会感受到在异乡的一种深入骨髓的孤独。出门在外结交的朋友、人脉，都是过客。我们每个人都很清楚，这个月还是同事，可能下个月就分道扬镳了。也是因为投资这种人际关系几乎是毫无价值，大家能做的也只有尽量不互相打扰。这也是为什么，在异乡，从底层到高级一点的劳动者都会选择和老乡抱团取暖，也许老乡这层关系，要稍稍紧密一点。</p>
<p>来传音工作之后，搬到了张江这里。阿文的室友要去广州奋斗，因此房间转让给了我。本来是客厅隔出来的两间房，后来中间隔断被拆了。因此我和阿文开始了五个月的“同居生活”。</p>
<p>阿文是湖北人，沉默寡言，所以往往是我找他聊天。我很难忍受没人可以说话聊天的日子，但他好似习惯如此。相比于我，他的生活习惯特别规律。每天晚上十点多他睡觉的时候，只是默默的躺在床上开睡。我提醒他很多次，他要睡觉就把灯关了。而他怕关灯影响我玩电脑总是很少关，因此每次都是我主动去把灯关了再继续用电脑。我觉得遇到这样的一个生活习惯好的室友是非常不容易的。起码我就不是一个好室友–性格懒惰，生活不规律。</p>
<p>阿文和我一样，都是程序员。都是Java程序员，但他是做后台，我是做Android。虽然我也“标榜”自己热爱学习，但很多时候我都很懒而去看斗鱼、熊猫直播了。而他几乎每天都会去学习一阵子。这几个月里，他一直在研究Java并发操作那本书。</p>
<p>这次搬家距离不远，我闲的发慌没有叫车，蚂蚁搬家式的靠着一个小拉杆箱和书包把所有的东西都搬到了新的房子。尽管我一再婉拒，阿文还是帮我一起搬了好多次。不然今天晚上可能我都还没搬完。我现在的感觉就和小时候和转学的小伙伴告别类似。茫茫人海，我们知道从此彼此再无交集。</p>
<p>从我高中毕业之后，我在太多城市生活过：北京、南京、天津、苏州、深圳、上海，我认识了太多人，也告别了太多人。那么多像阿文这样的人，成为了我生命中的过客，我也成为了他们的过客。漂泊异乡，我们对彼此的影响根本就不值一提！但不知为何，就是这种不值一提的渺小感让我略有悲怆之感，我甚至根本没有任何理由去写文纪念谁，纪念哪一段时光。</p>
<p>不论是更不体面一点的建筑工人，还是貌似高级打工者的程序员，我们都是这座城市微不足道的过客（当然不排除有些人真的完成了定居魔都的壮举）。我们没有诗和远方，也算不上苟且偷生。除了讨生活之外我似乎找不到在我之余这座城市、这座城市之于我的意义。我们没有可歌可泣的感人故事，也没有平淡恬静的平凡生活可以歌颂。认识一群人，然后告别一群人，在这循环往复之中，我真的是有写怕了。我怕认识新的人，因为我知道迟早也要和他们成为陌路。结交朋友对于我这样的人确实会很累，尤其是你知道这毫无用处。</p>
<p>我突然想起了关于蜗牛的一段话，虽然有点文不对题：两只陌生的蜗牛在某个路口相遇了，它们彼此碰了碰触角，互致问候，然后继续向前爬去。</p>
<p> 2017.7.24夜</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/24/%E9%AD%94%E9%83%BD%EF%BC%8C%E8%AE%A4%E7%9C%9F%E5%91%8A%E5%88%AB%E6%AF%8F%E4%B8%80%E4%B8%AA%E8%BF%87%E5%AE%A2/" data-id="ckj2v1sq0000ebkusa4jw1bbz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android性能优化之工具和优化点总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/24/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%B7%A5%E5%85%B7%E5%92%8C%E4%BC%98%E5%8C%96%E7%82%B9%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2017-07-24T08:13:16.000Z" itemprop="datePublished">2017-07-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/24/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%B7%A5%E5%85%B7%E5%92%8C%E4%BC%98%E5%8C%96%E7%82%B9%E6%80%BB%E7%BB%93/">Android性能优化之工具和优化点总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Android性能优化学习"><a href="#Android性能优化学习" class="headerlink" title="Android性能优化学习"></a>Android性能优化学习</h1><blockquote>
<p>本文为作者原创，转载请注明作者和出处</p>
</blockquote>
<blockquote>
<p>最近公司主抓性能优化工作，借此春风也学习到了许多Android性能优化方面的知识。由于组内队友的给力，优化的成果也是比较喜人。同时也学习和实践了不少知识，特此记录。</p>
</blockquote>
<h2 id="1-性能优化分析工具学习"><a href="#1-性能优化分析工具学习" class="headerlink" title="1.性能优化分析工具学习"></a>1.性能优化分析工具学习</h2><p>工欲善其事，必先利其器。在开始代码优化之前，先得学会使用性能分析工具。以下三个工具都是谷歌官方推出的，可以帮助我们定位分析问题，从而优化我们的APP。</p>
<ul>
<li><strong>System Trace</strong></li>
</ul>
<p>Systrace是一个收集和检测时间信息的工具, 它能显示CPU和时间被消耗在哪儿了, 每个进程和线程都在其CPU时间片内做了什么事儿. 而且会指示哪个地方出了问题, 以及给出Fix建议。给出的结果trace文件是以html形式打开的，直接用浏览器打开查看十分方便。打开方法：打开DDMS后，连接手机，点击手机上方一排按钮中的SysTrace按钮。<br>打开的效果如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/851999-8d1e74018a647416.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="System Trace"></p>
<p>在代码中打点方式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Trace.beginSection(&quot;name&quot;);</span><br><span class="line">&#x2F;&#x2F;要检测运行时间的代码</span><br><span class="line">Trace.endSection();</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Hierarchy Viewer</strong></li>
</ul>
<p>Hierarchy Viewer提供了一个可视化的界面来观测布局的层级, 让我们可以优化布局层级, 删除多余的不必要的View层级, 提升布局速度。另外，开发者模式中调试GPU过度绘制选项也可以进行视图层级调试。在SDK-&gt; tools目录下打开hierarchyviewer.bat即可。<br>效果如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/851999-62c25b5d13bbe59d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Hierarchy Viewer"></p>
<ul>
<li><strong>TraceView</strong></li>
</ul>
<p>一个图形化的工具, 用来展示和分析方法的执行时间。也是一款性能优化的神器。可以通过像打log一样的方式去定位代码的执行时间，从而可以准确定位是哪一段代码的执行消耗了太多时间。相比SysTrace，功能更强大，使用起来也更复杂。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/851999-34ccf981a85d9175.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TraceView"></p>
<h2 id="2-布局优化"><a href="#2-布局优化" class="headerlink" title="2.布局优化"></a>2.布局优化</h2><p>布局优化相对比较容易，优化可以先从布局来展开。使用Hierarchy Viewer和开发者模式中关于布局绘制的选项，可以查到一些问题然后进行修改。</p>
<ul>
<li><p><strong>布局嵌套过深</strong> 有的时候为了赶进度，布局设计的不是很好。层级嵌套过深的话，深度遍历各个节点会非常消耗时间，这也是布局优化余地最大的一个点了。很多过深的层级是不必要的。如果布局真的很复杂，不深度嵌套没法实现想要的效果。试试最新的约束布局Constraintlayout吧。没有使用过的话，下面这篇官方文档可以帮助你：<br><a target="_blank" rel="noopener" href="https://developer.android.com/training/constraint-layout/index.html">Constraintlayout官方介绍文档</a></p>
</li>
<li><p><strong>使用合适的布局</strong> 三种常见的ViewGroup的绘制速度：FrameLayout &gt; LinerLayout &gt; RelativeLayout。当然，如果用RelativeLayout可以避免布局嵌套的话是值得的。可以根据这些去决定选用什么样的布局。</p>
</li>
<li><p><strong>列表控件优化</strong> 不论是ListView还是RecycleView都有优化点，一个是convertView的复用，一个是ViewHolder的使用避免重复遍历节点。当然这些都是基础中的基础了。如果发现项目中的代码ListView或者RecycleView的使用不规范的话，赶紧进行修改吧。</p>
</li>
<li><p><strong>使用include标签</strong> 在布局文件中，<include>标签可以指定插入一段布局文件到当前布局。这样的话既提高了布局复用，也减少了我们的代码书写。另外，<merge>标签可以和<include>的标签一起使用从而减少布局层级。</p>
</li>
<li><p><strong>ViewStub延时加载</strong> 有些布局，比如网络出错的布局，没必要在所有时候都加载出来。使用ViewStub可以实现按需加载。ViewStub本身没有宽高，加载起来几乎不消耗什么资源。当对他setVisibility(View.VISIBLE)的时候会调用它引用的真实布局填充到当前位置，从而实现了延时加载，节省了正常加载的时间。</p>
</li>
<li><p><strong>移除Activity默认背景</strong> 只要我们不需要Activity的默认背景，就可以移除掉，以减少Activity启动时的渲染时间，提升启动效率。移动方法见下：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name&#x3D;&quot;MyStyle&quot; parent&#x3D;&quot;AppTheme&quot;&gt;</span><br><span class="line">       &lt;item name&#x3D;&quot;android:windowNoTitle&quot;&gt;true&lt;&#x2F;item&gt;</span><br><span class="line">       &lt;item name&#x3D;&quot;android:windowBackground&quot;&gt;@null&lt;&#x2F;item&gt;  </span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<h2 id="3-线程优化"><a href="#3-线程优化" class="headerlink" title="3.线程优化"></a>3.线程优化</h2><p>线程的创建和销毁会带来比较大的性能开销。因此线程优化也很有必要。查看项目中是否存在随意new thread，线程缺乏管理的情况。使用AsyncTask或者线程池对线程进行管理，可以提升APP的性能。另外，我比较推荐使用Rxjava来实现异步操作，既方便又优雅。</p>
<p><a target="_blank" rel="noopener" href="http://gank.io/post/560e15be2dca930e00da1083">推荐一篇Rxjava的入门文章</a></p>
<h2 id="4-内存泄露"><a href="#4-内存泄露" class="headerlink" title="4.内存泄露"></a>4.内存泄露</h2><p>内存泄露会导致APP占用内存过高，影响效率，严重的话会导致OOM。因此如果项目存在内存泄露的话要优先解决。查找内存泄露可以用LeakCanary等工具，具体怎么解决，有哪些泄露点，以后有时间也写篇总结。</p>
<h2 id="5-算法优化"><a href="#5-算法优化" class="headerlink" title="5.算法优化"></a>5.算法优化</h2><p>毋庸置疑，使用合适的算法处理事务可以大幅提升APP的性能。当然算法不是我的强项，也只能给出一些大致的点：查询考虑二分查找节省时间，尽量不要使用耗时的递归算法。必要的时候可以空间换时间来提高APP运行效率。</p>
<h2 id="6-其他优化点"><a href="#6-其他优化点" class="headerlink" title="6.其他优化点"></a>6.其他优化点</h2><ul>
<li><p><strong>异步处理耗时任务</strong> 在Activity、Fragemnt的onCreate等初始化方法中，如果执行了太耗时的操作（例如读取各种数据），会影响页面的加载速度，让用户觉得APP太慢。这时候可以异步处理这些耗时任务，减小应用启动的时候的负担。</p>
</li>
<li><p><strong>替换矢量图</strong> 尽管矢量图有诸多优点，但矢量图的绘制是消耗性能的。在应用初始化加载等比较影响用户体验的地方，还是建议使用Bitmap来代替矢量图，提高APP开启效率。</p>
</li>
<li><p><strong>正则表达式</strong> 经小伙伴用TraceView不断的打点发现，正则表达式非常消耗时间。因此尽管正则表达式非常优雅，涉及到性能问题的时候，可以改为其他判断方式来提高APP性能。</p>
</li>
<li><p><strong>浮点类型</strong> 在Java中浮点类型的运算大概比整型数据慢两倍，因此整型数据能解决的问题尽量用整型。</p>
</li>
<li><p><strong>减少冗余log</strong> 开发的时候用于调试的log，在项目上线的时候没用的要及时删除。当然有用的log还是要留下，以便以后分析问题。</p>
</li>
<li><p><strong>删除无用资源</strong> 没用用的资源会增大APK大小，既然没有用了，上线的时候当然要及时删除。</p>
</li>
<li><p><strong>Lint代码检查</strong> 使用Lint等静态代码检查工具可以帮助我们发现很多隐藏的问题。Lint检查出来的问题越少，说明代码越规范，越不容易出现各种问题，APP性能自然也会提升。</p>
</li>
<li><p><strong>滥用全局广播</strong> 全局广播也是十分消耗性能的一个点。对于应用内的通讯，使用接口回调，EventBus等手段比起广播是更好地选择。动态注册广播的时候，也不要忘了广播的注销。</p>
</li>
</ul>
<p>##7.总结<br>可以看到除了工具的使用外，性能优化是很考验代码功底的。因此想要做好性能优化，强化基本功不可少。性能优化也是一件相对枯燥而难度大的工作。因为很多优化的努力可能立马看不到效果，或者说优化的成果在数据上难以体现。我们在做性能优化的时候也遇到果瓶颈，找不到优化方向而感到泄气。但是坚持下来，利用好工具，从各个点去优化，总会有拨开云雾见青天的一天！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/24/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%B7%A5%E5%85%B7%E5%92%8C%E4%BC%98%E5%8C%96%E7%82%B9%E6%80%BB%E7%BB%93/" data-id="ckj2v1spz000cbkus6h603kuw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Handler源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/10/Handler%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="article-date">
  <time datetime="2017-05-10T08:13:39.000Z" itemprop="datePublished">2017-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/10/Handler%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">Handler源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文为作者原创，转载请注明链接</p>
</blockquote>
<blockquote>
<p>Handler的运行机制是Android程序员面试中经常被问到的一个问题，因为该问题可以考察面试者对于Android源码的了解程度。本文将以源码的角度来探索Handler的机制和原理。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/5586297-ebad33f3bcaf7fb8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Handler消息处理机制"></p>
<p>这张图是本人画的，下面通过绑定Looper和MessageQueue、发送消息、处理消息三个步骤来解析Handler的源码。<br>##Looper.prepare()和Looper.loop()方法<br>要在某一个线程中使用Handler接受处理消息，必须在该线程中执行这两个方法。那为什么我们平时好像没有调用过着两个方法呢？那是因为Android主线程已经帮我们调用了这两个方法。例如要在子线程中使用Handler接收处理消息，就需要我们自己手动调用这两个方法了。在本文中只讨论在主线程中使用Handler接受处理消息的情况(在子线程的情况也是一样的)。</p>
<p>先来看看Looper.prepare()和Looper构造函数的源码：</p>
<pre><code>public static void prepare() &#123;
    prepare(true);
&#125;

private static void prepare(boolean quitAllowed) &#123;
    if (sThreadLocal.get() != null) &#123;
        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
    &#125;
    sThreadLocal.set(new Looper(quitAllowed));
&#125;

private Looper(boolean quitAllowed) &#123;
    mQueue = new MessageQueue(quitAllowed);
    mThread = Thread.currentThread();
&#125;</code></pre>
<p>可以看到在这段源码中，new了一个Looper对象保存到了sThreadLocal中。那么ThreadLocal又是什么东西呢？ThreadLocal是一个线程内部的数据存储类，这里不展开介绍它。简单来说ThreadLocal可以根据不同的线程保存和读取不同的数据，由于Handler使用的时候就是多线程的情景，在这里使用ThreadLocal来保存主线程中的Looper对象再合适不过了。而在Looper的构造函数中，new了一个MessageQueue并赋值给成员变量mQueue，即为该Looper对象绑定了一个MessageQueue。</p>
<p>那么这段代码总结起来，它的目的就是在为主线程创造并绑定一个Looper对象，并为该Looper对象绑定一个MessageQueue对象。</p>
<p>下面再来看看Looper.loop()方法做了什么事：</p>
<pre><code>public static void loop() &#123;
    final Looper me = myLooper();
    if (me == null) &#123;
        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&#39;t called on this thread.&quot;);
    &#125;
    final MessageQueue queue = me.mQueue;

    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();

    for (;;) &#123;
        Message msg = queue.next(); // might block
        if (msg == null) &#123;
            // No message indicates that the message queue is quitting.
            return;
        &#125;
        ......
    &#125;
&#125;</code></pre>
<p>这段源码就比较长了，没关系我们只看重点。</p>
<p>首先通过myLooper()方法拿到looper对象，然后通过该对象拿到MessageQueue对象queue。下面使用Binder和底层通信，这里不展开。</p>
<p>重点在于下面的无限for循环。for (;;)非常简单粗暴，调用了MessageQueue的next()方法。后面的注释提示了这个方法可能会阻塞。如果返回的消息为null，代表MessageQueue已退出，return退出loop()方法。如果MessageQueue中没有消息对象，next()方法会阻塞，直到再有消息传进来。</p>
<p>##Handle发送消息方法<br>Handle的sendMessage方法最终调用的是sendMessageAtTime方法，来看看这个方法干了什么：</p>
<pre><code>public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;
    MessageQueue queue = mQueue;
    if (queue == null) &#123;
        RuntimeException e = new RuntimeException(
                this + &quot; sendMessageAtTime() called with no mQueue&quot;);
        Log.w(&quot;Looper&quot;, e.getMessage(), e);
        return false;
    &#125;
    return enqueueMessage(queue, msg, uptimeMillis);
&#125;</code></pre>
<p>很简单，先判断有没有绑定的MessageQueue对象，如果没有就要抛异常。有的话执行enqueueMessage方法。</p>
<pre><code>private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;
    msg.target = this;
    if (mAsynchronous) &#123;
        msg.setAsynchronous(true);
    &#125;
    return queue.enqueueMessage(msg, uptimeMillis);
&#125;</code></pre>
<p>msg.target这个成员变量就是Hanlder类，赋值为this代表，把消息发给调用这个方法的Handler。然后执行queue.enqueueMessage方法。这个方法将消息加进MessageQueue中，如果原来的MessageQueue中没有消息，会唤醒它执行next()方法取消息。具体的源码涉及native层的操作，在这里就不展开讨论了，有兴趣的朋友可以研究下。</p>
<p>如果是用post(Runnable r)方法发消息呢？</p>
<pre><code>public final boolean postAtTime(Runnable r, long uptimeMillis) &#123;
    return sendMessageAtTime(getPostMessage(r), uptimeMillis);
&#125;

private static Message getPostMessage(Runnable r) &#123;
    Message m = Message.obtain();
    m.callback = r;
    return m;
&#125;</code></pre>
<p>可以看到最终调用的还是sendMessageAtTime方法，只是通过getPostMessage方法把runnable对象放进一个消息对象传出去。</p>
<p>##Handler处理消息<br>通过上面的流程，消息发出来了，进入MessageQueue中，我们在主线程又通过Looper.loop()方法把消息取出来了，那下面怎么处理消息呢？继续来看Looper.loop()方法，取出消息后有这么一段代码：</p>
<pre><code>try &#123;
    msg.target.dispatchMessage(msg);
&#125; finally &#123;
    if (traceTag != 0) &#123;
        Trace.traceEnd(traceTag);
    &#125;
&#125;</code></pre>
<p>msg.target是什么？不就是上面enqueueMessage方法中，我们传人的handle对象嘛。也就是说这里调用了handle对象的dispatchMessage(msg)方法来处理消息，继续看该方法：</p>
<pre><code>public void dispatchMessage(Message msg) &#123;
    if (msg.callback != null) &#123;
        handleCallback(msg);
    &#125; else &#123;
        if (mCallback != null) &#123;
            if (mCallback.handleMessage(msg)) &#123;
                return;
            &#125;
        &#125;
        handleMessage(msg);
    &#125;
&#125;

private static void handleCallback(Message message) &#123;
    message.callback.run();
&#125;</code></pre>
<p>首先判断消息中的callback是否为空，如果post(Runnable r)发来的消息，这里的callback就是传来的runnable对象了，调用handleCallback(msg)处理。这个方法就简单了，直接运行该runnable即可。</p>
<p>callback对象为空，会判断mCallback是否为空。这里的mCallback对象是Handler构造函数中传进来的，是Hanlder中的内部接口。如果有就回调接口实现的handleMessage(msg)方法。没有的话，调用handleMessage(msg)方法。该方法默认什么都不做，一般是我们自己重写该方法处理消息。</p>
<p>##总结<br>至此，Handler发送消息，取消息，处理消息的流程我们已经从源码的角度剖析完成了。下次面试再被问到就可以游刃有余地回答了。MessageQueue中的next()和enqueueMessage方法涉及到很多native方法，在本文中没有展开研究，有兴趣的朋友可以把这部分也搞明白了，对Handler机制会有一个更深的理解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/10/Handler%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" data-id="ckj2v1spx0008bkus67sg7zlz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android事件分发机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/02/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2017-05-02T08:14:10.000Z" itemprop="datePublished">2017-05-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/02/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/">Android事件分发机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文由本人原创，转载请注明作者</p>
</blockquote>
<p>Android中的事件分发机制是新手学习的一个重难点。而且往往学习了之后以为掌握的差不多了，但遇到新问题的时候又发现没有掌握到位或者又忘掉了。笔者就是这种情况，因此将自己已掌握的事件分发机制记录下来，作为记录和交流。</p>
<h1 id="一、背景目的"><a href="#一、背景目的" class="headerlink" title="一、背景目的"></a>一、背景目的</h1><ul>
<li>什么是Android事件分发机制？ <blockquote>
<p>事件分发机制是处理Android各种滑动冲突的理论基础，也是学习Android的核心知识点，掌握好View和ViewGroup的事件分发机制是十分重要的。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>为什么Android要设计一套事件分发机制？</p>
<blockquote>
<p>当父控件和子控件都可以响应用户输入作出行为的时候（比如触摸滑动），这时候就会造成事件冲突。如何判断用户的输入事件由父控件处理还是子控件处理，就需要设计出一套规则了，这套规则就是Android事件分发机制。</p>
</blockquote>
</li>
<li><p>没有子父关系的控件会出现事件冲突吗？</p>
<blockquote>
<p>没有子父关系的控件，它们是不会产生事件冲突的。因此在处理事件冲突的时候，首先要分析产生冲突的子控件是哪一个，父控件是哪一个。</p>
</blockquote>
</li>
</ul>
<h1 id="二、基础知识"><a href="#二、基础知识" class="headerlink" title="二、基础知识"></a>二、基础知识</h1><ul>
<li>View和ViewGroup </li>
</ul>
<p>Android中的控件大致可以分为两类，分别是View和ViewGroup。其中ViewGroup实际上也是继承自View。ViewGroup表示可以拥有子控件的控件，常见的有LinearLayout、ListView这些。后面我们将通过学习知道，在Android事件分发机制中，View是没有拦截方法的，而ViewGroup的拦截方法没有重写的话默认也是不进行拦截的。</p>
<ul>
<li>MotionEvent分类</li>
</ul>
<p>Android设备可以接收的事件总类很多，比如按压、拖拽、滑动，这些事件分类是由android底层完成的。总的来说，用户操作可以分为三类，及MotionEvent中的ACTION_DOWN（按下），ACTION_MOVE（移动），ACTION_UP（抬起）。从用户手指按下到抬起这一连串的事件被称之为一个事件序列。关于事件序列，下面也会说到。</p>
<h1 id="三、事件分发流程"><a href="#三、事件分发流程" class="headerlink" title="三、事件分发流程"></a>三、事件分发流程</h1><p><img src="http://upload-images.jianshu.io/upload_images/5586297-c462585648e867b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自网络"><br>从这张图片来看一次点击事件的传递。在这张图中有三个存在子父View关系的View，其中上面两个能作为父View的自然是属于ViewGroup了。</p>
<h3 id="ViewGroup—dispatchTouchEvent方法"><a href="#ViewGroup—dispatchTouchEvent方法" class="headerlink" title="ViewGroup—dispatchTouchEvent方法"></a>ViewGroup—dispatchTouchEvent方法</h3><p>Touch事件发生后，顶级父View先接受到消息，此时会先调用顶级View的dispatchTouchEvent方法，这在图片上没有画出来。该方法的返回true的话，代表事件被消费掉了（当事件被消费时便不再传递）；返回false的话事件不再往下传递，由上一级View的onTouchEvent方法来处理。如果没有重写该方法的话（即调用ViewGroup中的dispatchTouchEvent方法），会判断onInterceptTouchEvent的返回值来确定下一步传递方向。</p>
<h3 id="ViewGroup—onInterceptTouchEvent方法"><a href="#ViewGroup—onInterceptTouchEvent方法" class="headerlink" title="ViewGroup—onInterceptTouchEvent方法"></a>ViewGroup—onInterceptTouchEvent方法</h3><p>该方法顾名思义，判断当前View是否拦截该事件。如图所示，返回Ture的话会拦截事件传递，调用顶级View的onTouchEvent方法来处理事件。返回false的话表示不中断，事件继续向下传递。传递到下一级父View的过程也是一样，onInterceptTouchEvent方法返回false的话会一直向下传递到子View。</p>
<h3 id="View-dispatchTouchEvent方法"><a href="#View-dispatchTouchEvent方法" class="headerlink" title="View-dispatchTouchEvent方法"></a>View-dispatchTouchEvent方法</h3><p>View的dispatchTouchEvent方法跟ViewGroup是有区别的。通过看源码可以知道，View没有onInterceptTouchEvent方法，因此也它会直接调用onTouchEvent方法来判断事件是否被消耗。另外如果View被设置了各种Listener（如OnClickListener）之后，对应的事件也会随着Listener中对应的方法返回true而被消耗。</p>
<h3 id="View—onTouchEvent方法"><a href="#View—onTouchEvent方法" class="headerlink" title="View—onTouchEvent方法"></a>View—onTouchEvent方法</h3><p>传递到子View的时候会调用子View的dispatchTouchEvent方法，一般自定义View的时候在onTouchEvent中处理与用户触摸按压的交互逻辑。不管该方法过程如何，如果onTouchEvent的返回值为True表示事件被消耗，事件不再传递。反之，事件将向上传递，传给父View去处理。另外需要注意的是当View的clickable和longClickabale属性同时为false的时候，代表View不可点击（如TextView），因此onTouchEvent方法也会默认返回false不消耗事件。</p>
<h3 id="ViewGroup—onTouchEvent方法"><a href="#ViewGroup—onTouchEvent方法" class="headerlink" title="ViewGroup—onTouchEvent方法"></a>ViewGroup—onTouchEvent方法</h3><p>ViewGroup对onTouchEvent的方法和View一样，返回true的话代表事件被消耗，返回false将事件继续向上传递。具体的行为要看具体的重写方法。</p>
<h1 id="四、总结分发流程"><a href="#四、总结分发流程" class="headerlink" title="四、总结分发流程"></a>四、总结分发流程</h1><p>可以看到事件传递时是一层层向下传递接受，再由下往上进行处理。这和现实工作也很类似：</p>
<blockquote>
<p>产品经理提了一个新的需求，高级程序员接到需求先考虑下要不要自己做（onInterceptTouchEvent方法过程），觉得应该自己处理就自己完成了（ViewGroup—onTouchEvent方法过程）；觉得应该由下属去做就下发给见习程序员，见习程序员没有下属只能自己去处理（View—onTouchEvent方法过程）；见习程序员如果很好地解决需求了（onTouchEvent方法返回true），这个事件就到此结束了。如果需求太难，见习程序员处理不了这个需求（onTouchEvent方法返回false），那么就会再交给上级去处理。</p>
</blockquote>
<p>可见Google的程序员在设计这些代码时的用的方法十分巧妙，也是和现实相结合地去设计代码，对于开发者也便于理解。<br>任玉刚大神在《Android开发艺术探索》一书中对事件分发机制的讲解十分到位，推荐有兴趣的朋友去看看。书中用一段伪代码把事件分发机制抽象的非常清楚：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> consume =<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(onInterceptTouchEvent(ev)) &#123;</span><br><span class="line">        consume = onTouchEvent(ev);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        consume = child.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中comsume代表事件是否被消耗。当事件传递到ViewGroup的时候，先判断是否拦截。拦截的话由自己的onTouchEvent方法处理；不拦截的话，分发给子View处理，调用子View的dispatchTouchEvent方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/02/Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/" data-id="ckj2v1spw0007bkus9cfid82t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-geenDao使用介绍——如何开始？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/24/geenDao%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E5%BC%80%E5%A7%8B%EF%BC%9F/" class="article-date">
  <time datetime="2017-04-24T08:14:43.000Z" itemprop="datePublished">2017-04-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/24/geenDao%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E5%BC%80%E5%A7%8B%EF%BC%9F/">geenDao使用介绍——如何开始？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文由本人翻译自greenDao官方文档，转载请注明作者</p>
</blockquote>
<h1 id="greenDao简介"><a href="#greenDao简介" class="headerlink" title="greenDao简介"></a>greenDao简介</h1><p><img src="http://upload-images.jianshu.io/upload_images/5586297-7c8c79b375a7b02f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="greenDao与数据库和Java对象的映射关系"><br>greenDao是一个用于Android的ORM（对象关系映射）工具。它提供了一个面向对象的接口来进行SQlite数据库的操作。greenDao这样的ORM工具可以替你做很多重复的操作，并为你提供一个简单的接口来操作你的数据。</p>
<h1 id="在Gradle中配置greenDao"><a href="#在Gradle中配置greenDao" class="headerlink" title="在Gradle中配置greenDao"></a>在Gradle中配置greenDao</h1><p>为了在你的Android项目中使用greenDao，需要在gradle中进行配置并添加依赖库。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In your root build.gradle file:</span></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenCentral() <span class="comment">// add repository</span></span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&#x27;com.android.tools.build:gradle:2.3.0&#x27;</span></span><br><span class="line">        classpath <span class="string">&#x27;org.greenrobot:greendao-gradle-plugin:3.2.2&#x27;</span> <span class="comment">// add plugin</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// In your app projects build.gradle file:</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;org.greenrobot.greendao&#x27;</span> <span class="comment">// apply plugin</span></span><br><span class="line"> </span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">&#x27;org.greenrobot:greendao:3.2.2&#x27;</span> <span class="comment">// add library</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="如何开始使用"><a href="#如何开始使用" class="headerlink" title="如何开始使用"></a>如何开始使用</h1><p>下面我们通过一个简单的官方项目示例——<a target="_blank" rel="noopener" href="https://github.com/greenrobot/greenDAO/tree/master/examples/DaoExample">DaoExample</a>来帮助你开始使用GreenDao。你可以自由克隆这个项目的代码并运行，或者直接在github上查看代码。<br>DaoExample是一个简单的记录笔记的安卓APP，你可以添加新的笔记，或者点击一个已存在的笔记来删除它。</p>
<p>#笔记实体和DAO类（The Note entity and DAO class）<br>我们直接来看代码，在src目录下你会找到叫<a target="_blank" rel="noopener" href="https://github.com/greenrobot/greenDAO/blob/master/examples/DaoExample/src/main/java/org/greenrobot/greendao/example/Note.java">Note.java</a>的笔记实体类。这个类包含了一个笔记的所有数据，比如笔记的id，内容，创建时间等信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity(indexes = &#123;</span></span><br><span class="line"><span class="meta">    @Index(value = &quot;text, date DESC&quot;, unique = true)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Note</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>大致来说，实体类是表示数据库信息的一个类，它的每一个属性，代表了数据库表中相对应的列。<br>现在开始编译这个项目，比如在Android Studio中使用 <strong>Build&gt;Make Project</strong>，这会触发greenDao生成DAO(Data Access Object)类，例如这个项目中的NoteDao.java，它可以帮助我们添加笔记到数据库中。</p>
<p>#添加和删除笔记<br>为了学习怎样添加笔记，我们来看<a target="_blank" rel="noopener" href="https://github.com/greenrobot/greenDAO/blob/master/examples/DaoExample/src/main/java/org/greenrobot/greendao/example/NoteActivity.java">NoteActivity.java</a>这个类。首先我们需要为Note这个实体准备一个DAO类，我们在onCreate方法中获取DAO对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get the note DAO</span></span><br><span class="line">DaoSession daoSession = ((App) getApplication()).getDaoSession();</span><br><span class="line">noteDao = daoSession.getNoteDao();</span><br></pre></td></tr></table></figure>
<p>当用户点击按钮，addNote()方法被执行。在这个方法里，我们创建一个笔记实例，并通过DAO对象的insert()方法将它添加到数据库中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Note note = <span class="keyword">new</span> Note();</span><br><span class="line">note.setText(noteText);</span><br><span class="line">note.setComment(comment);</span><br><span class="line">note.setDate(<span class="keyword">new</span> Date());</span><br><span class="line">note.setType(NoteType.TEXT);</span><br><span class="line">noteDao.insert(note);</span><br><span class="line">Log.d(<span class="string">&quot;DaoExample&quot;</span>, <span class="string">&quot;Inserted new note, ID: &quot;</span> + note.getId());</span><br></pre></td></tr></table></figure>
<p>在将这个笔记添加到数据库的时候我们没有为其指定id，这种情况下数据库会自动为其设置一个id。<br>删除一个笔记也非常简单，见NoteClickListener方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">noteDao.deleteByKey(id);</span><br></pre></td></tr></table></figure>
<h1 id="修改笔记"><a href="#修改笔记" class="headerlink" title="修改笔记"></a>修改笔记</h1><p>示例项目中没有修改笔记的操作，不过也非常简单：只要在改变笔记的任何属性之后调用DAO的update方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">note.setText(<span class="string">&quot;This note has changed.&quot;</span>);</span><br><span class="line">noteDao.update(note);</span><br></pre></td></tr></table></figure>
<p>除此之外还有其他的一些<strong>增、删、改、查</strong>的方法，greenDao所有DAO类都继承自<a target="_blank" rel="noopener" href="http://greenrobot.org/files/greendao/javadoc/current/org/greenrobot/greendao/AbstractDao.html#method.summary">the AbstractDao class</a>，可以查看这个类来学习更多的方法。</p>
<h1 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h1><p>我们已经学习了DAO类的使用，那么我们是如何初始化greenDao和其内在的数据库呢？一般情况下，我们需要初始化一个<a target="_blank" rel="noopener" href="http://greenrobot.org/files/greendao/javadoc/current/org/greenrobot/greendao/AbstractDaoSession.html">DaoSession</a>，通常在项目的<a target="_blank" rel="noopener" href="https://github.com/greenrobot/greenDAO/blob/master/examples/DaoExample/src/main/java/org/greenrobot/greendao/example/App.java">the Application class</a>中进行初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DevOpenHelper helper = <span class="keyword">new</span> DevOpenHelper(<span class="keyword">this</span>, <span class="string">&quot;notes-db&quot;</span>);</span><br><span class="line">Database db = helper.getWritableDb();</span><br><span class="line">daoSession = <span class="keyword">new</span> DaoMaster(db).newSession();</span><br></pre></td></tr></table></figure>
<p>数据库通过<strong>DevOpenHelper</strong>这个helper类来创建，这个类由<strong>DaoMaster</strong>提供，它是DaoMaster中继承自OpenHelper的内部类。它为你做好所有创建数据库的工作，你不需要再写”CREATE TABLE”这样的sql语句。<br>在activity和fragment中可以通过调用getDaoSession()方法来获得DaoSession并进一步获得实体DAO类，如上面添加和删除笔记那样。</p>
<h1 id="扩展和添加实体类"><a href="#扩展和添加实体类" class="headerlink" title="扩展和添加实体类"></a>扩展和添加实体类</h1><p>为了扩展我们的Note类或者创建新的实体类，你只要修改或创建新的java类，然后加上注解，重新Build项目就可以了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/24/geenDao%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E5%BC%80%E5%A7%8B%EF%BC%9F/" data-id="ckj2v1spo0006bkushvmzc39v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android开发中的长度单位详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/14/Android%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%95%BF%E5%BA%A6%E5%8D%95%E4%BD%8D%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2017-04-14T08:15:01.000Z" itemprop="datePublished">2017-04-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/14/Android%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%95%BF%E5%BA%A6%E5%8D%95%E4%BD%8D%E8%AF%A6%E8%A7%A3/">Android开发中的长度单位详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>当我们在Android Studio或者Eclipse中编辑布局的时候，开发工具会提示我们使用dp、sp、px、in、pt、mm这六种单位。那么这六种单位各自代表什么含义，需要在什么地方使用呢？</p>
</blockquote>
<p>###六种单位介绍</p>
<ul>
<li><strong>px</strong> : 像素(pixels)，即屏幕上的像素点，1px代表占据一个像素点。</li>
<li><strong>dp</strong> : 独立像素(device independent pixels)，这是我们使用最多的一种单位，一般来说我们在布局文件中定义控件的宽高等属性时都会使用它。它是一种能够自动适应不同屏幕密度的单位，在160dpi的屏幕上，1dp = 1px。由于Android碎片化严重，使用它作为长度单位可以适配不同的屏幕密度。</li>
<li><strong>sp</strong> : 比例像素(scaled pixels)，我们定义字体大小的时候，一般都会使用sp作单位。sp除了能够像dp一样可以适应屏幕密度的变化，还可以随着系统字体的大小设置改变作出变化。如果产品经理不想文字随着手机设置中字体的大小发生改变（例如标题），可以使用dp代替。</li>
<li><strong>in</strong> : 英寸(inch)，屏幕的物理尺寸，1 inch = 2.54cm。</li>
<li><strong>pt</strong> : 点(point，也是屏幕的物理尺寸，1 pt = 1/72 inch。</li>
<li><strong>mm</strong> : 毫米(millimeter)，后面三种都是物理尺寸，在Android开发中不常用。<br>###dp和px的换算</li>
<li>*<em>1px = 1dp * (density / 160)*</em><br>dp和px的换算关系如上公式所示，density代表当前屏幕密度。常见的手机屏幕像素及对应分别率级别如下表所示：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">级别</th>
<th align="center">分辨率</th>
<th align="center">dpi大小</th>
<th align="center">dp:dx</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ldpi</td>
<td align="center">320*240</td>
<td align="center">120dpi</td>
<td align="center">0.75</td>
</tr>
<tr>
<td align="center">mdpi</td>
<td align="center">480*320</td>
<td align="center">160dpi</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">hdpi</td>
<td align="center">800*480</td>
<td align="center">240dpi</td>
<td align="center">1.5</td>
</tr>
<tr>
<td align="center">xdpi</td>
<td align="center">1280*720</td>
<td align="center">320dpi</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">xxdpi</td>
<td align="center">1920*1080</td>
<td align="center">120dpi</td>
<td align="center">3</td>
</tr>
</tbody></table>
<ul>
<li>dpi表示屏幕像素密度，代表每平方英寸的像素数量。<br>###在代码中转换单位</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textView.setTextSize(<span class="number">2</span>,<span class="number">14</span>);</span><br></pre></td></tr></table></figure>
<p>代码中设置的属性单位默认是px，我们需要对其作适当的转换。例如，上面的代码中，给TextView设置文字大小。第一个参数代表单位，这里的2代表sp，第二个参数代表大小。具体的单位指代可以在源码中看到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DensityUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据手机的分辨率从 dip 的单位 转成为 px(像素)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dip2px</span><span class="params">(Context context, <span class="keyword">float</span> dpValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> scale = context.getResources().getDisplayMetrics().density;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (dpValue * scale + <span class="number">0.5f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据手机的分辨率从 px(像素) 的单位 转成为 dp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">px2dip</span><span class="params">(Context context, <span class="keyword">float</span> pxValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> scale = context.getResources().getDisplayMetrics().density;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (pxValue / scale + <span class="number">0.5f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以封装一个上面代码中的工具类，在代码中使用长度时先使用工具类进行转换。<br>###总结<br>一般来说，我们在android开发中为了适配不同像素密度的屏幕，要避免使用px作单位。如果UI妹子给的效果图用的px作单位，我们要转换未dp，具体的公式在上面有。在设置文字大小时使用sp，除非不想文字随着系统字体设置变化大小。在代码中设置的长度单位默认是px，需要转换为dp或者sp。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/14/Android%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%95%BF%E5%BA%A6%E5%8D%95%E4%BD%8D%E8%AF%A6%E8%A7%A3/" data-id="ckj2v1spb0001bkusczh6en7y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android-Studio升级到2-3之后无限转圈的问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/09/Android-Studio%E5%8D%87%E7%BA%A7%E5%88%B02-3%E4%B9%8B%E5%90%8E%E6%97%A0%E9%99%90%E8%BD%AC%E5%9C%88%E7%9A%84%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2017-04-09T08:15:19.000Z" itemprop="datePublished">2017-04-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/09/Android-Studio%E5%8D%87%E7%BA%A7%E5%88%B02-3%E4%B9%8B%E5%90%8E%E6%97%A0%E9%99%90%E8%BD%AC%E5%9C%88%E7%9A%84%E9%97%AE%E9%A2%98/">Android Studio升级到2.3之后无限转圈的问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近Android Studio终于可以升级到2.3啦，可是很多人升级到2.3之后却发现AS报错或者一直在refresh。发现解决方法之后在此记录以下。</p>
<p>Android Studio更新提示<br>点击第一个按钮AS就会开始更新，如果没有推送的话，点击Help —》check update会弹出来。</p>
<p>升级好之后打开项目发现AS一直卡在原地转圈，怎么办？</p>
<p>设置中选择gradle路径<br>我们打开设置界面，会告诉我们Gradle的地址错误。</p>
<p>我这里项目的Gradle版本由原来的2.14.1变成了3.2，选择3.2的版本点OK。</p>
<p>重新选择gradle版本<br>选择好之后AS还在转圈怎么办？强行关闭进程，重新启动。</p>
<p>重新打开之后，AS开始正常下载一些东西，不会无限转圈圈啦。等下载完之后就会正常编译了。</p>
<p>注意，在以前用旧版本gradle编译的项目都要手动去修改gradle目录，因为gradle已经进行了更新，不再是之前的目录啦。</p>
<p>gradle更新提示<br>另外，AS会提示升级gradle版本到3.3以上（那你给我更新个3.2是什么意思- -），点了的话如果升级不了可以去services.gradle.org/distributions里面下载3.3以上的版本。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/09/Android-Studio%E5%8D%87%E7%BA%A7%E5%88%B02-3%E4%B9%8B%E5%90%8E%E6%97%A0%E9%99%90%E8%BD%AC%E5%9C%88%E7%9A%84%E9%97%AE%E9%A2%98/" data-id="ckj2v1spe0003bkus89ol8tng" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/">Node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%88%AC%E8%99%AB/">爬虫</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/">项目管理</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-Studio/" rel="tag">Android Studio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Github/" rel="tag">Github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JPA/" rel="tag">JPA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Koa/" rel="tag">Koa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/" rel="tag">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/" rel="tag">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OKHttp/" rel="tag">OKHttp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Profiler/" rel="tag">Profiler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RESTful/" rel="tag">RESTful</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Boot/" rel="tag">Spring Boot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/" rel="tag">Ubuntu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ava/" rel="tag">ava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mongoose/" rel="tag">mongoose</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag">源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%88%AC%E8%99%AB/" rel="tag">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" rel="tag">环境配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%9F%E6%B4%BB/" rel="tag">生活</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/" rel="tag">职业规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" rel="tag">项目管理</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Android-Studio/" style="font-size: 12.5px;">Android Studio</a> <a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/JPA/" style="font-size: 10px;">JPA</a> <a href="/tags/JVM/" style="font-size: 12.5px;">JVM</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Koa/" style="font-size: 10px;">Koa</a> <a href="/tags/Kotlin/" style="font-size: 12.5px;">Kotlin</a> <a href="/tags/Linux/" style="font-size: 12.5px;">Linux</a> <a href="/tags/MongoDB/" style="font-size: 10px;">MongoDB</a> <a href="/tags/Node-js/" style="font-size: 15px;">Node.js</a> <a href="/tags/OKHttp/" style="font-size: 15px;">OKHttp</a> <a href="/tags/Profiler/" style="font-size: 10px;">Profiler</a> <a href="/tags/RESTful/" style="font-size: 10px;">RESTful</a> <a href="/tags/Spring-Boot/" style="font-size: 10px;">Spring Boot</a> <a href="/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a> <a href="/tags/ava/" style="font-size: 10px;">ava</a> <a href="/tags/git/" style="font-size: 12.5px;">git</a> <a href="/tags/mongoose/" style="font-size: 10px;">mongoose</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 10px;">性能优化</a> <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="font-size: 15px;">源码分析</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 10px;">爬虫</a> <a href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" style="font-size: 15px;">环境配置</a> <a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size: 12.5px;">生活</a> <a href="/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/" style="font-size: 10px;">职业规划</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 17.5px;">随笔</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" style="font-size: 10px;">项目管理</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/12/24/%E8%80%81%E5%AE%9E%E4%BA%BA%E6%80%95%E5%BC%80%E5%8F%A3/">老实人怕开口</a>
          </li>
        
          <li>
            <a href="/2019/01/01/2019%E7%AC%AC%E4%B8%80%E5%A4%A9%E5%85%88%E7%AB%8Bflag/">2019第一天先立flag</a>
          </li>
        
          <li>
            <a href="/2018/12/31/2018%E7%BB%99%E8%87%AA%E5%B7%B1%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%80%BB%E7%BB%93/">2018给自己一个简单的总结</a>
          </li>
        
          <li>
            <a href="/2018/12/29/%E4%BD%BF%E7%94%A8jsonwebtoken%E5%AE%8C%E6%88%90nodejs%E7%9A%84%E7%99%BB%E9%99%86%E7%B3%BB%E7%BB%9F/">使用jsonwebtoken完成nodejs的登陆系统</a>
          </li>
        
          <li>
            <a href="/2018/12/28/Android%E4%B8%89%E5%A4%A7%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84MVC%E3%80%81MVP%E3%80%81MVVM%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/">Android三大项目架构MVC、MVP、MVVM使用体验</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 业松<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>